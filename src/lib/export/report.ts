/**
 * Report Export Module
 *
 * Generates exportable reports from analysis sessions in multiple formats.
 * Supports JSON (full data) and Markdown (human-readable summary).
 */

import { AnalysisSession, scoreToGrade } from '../types/session';
import type { Finding as SessionFinding } from '../types/session';
import type { Finding as AnalysisFinding } from '../analysis/findings';

// Union type to support both finding formats
type AnyFinding = SessionFinding | AnalysisFinding;

/**
 * Flexible session type for export that accepts either finding format.
 * This allows exporting sessions with analysis findings that haven't been
 * transformed to session finding format.
 */
export type ExportableSession = Omit<AnalysisSession, 'findings'> & {
  findings: AnyFinding[];
};

// =============================================================================
// Constants
// =============================================================================

const APP_VERSION = '1.0.0';
const APP_NAME = 'Jalanea ATS';

// =============================================================================
// JSON Export
// =============================================================================

/**
 * Export options for JSON format
 */
export interface JsonExportOptions {
  /** Include full extracted text (can be large) */
  includeFullText?: boolean;
  /** Pretty print with indentation */
  prettyPrint?: boolean;
}

/**
 * Exports a session to JSON format.
 *
 * @param session - The analysis session to export
 * @param options - Export options
 * @returns JSON string of the session data
 */
export function exportToJSON(
  session: ExportableSession,
  options: JsonExportOptions = {}
): string {
  const { includeFullText = true, prettyPrint = true } = options;

  // Create export object with metadata
  const exportData = {
    meta: {
      exportedAt: new Date().toISOString(),
      appVersion: APP_VERSION,
      appName: APP_NAME,
      format: 'json',
    },
    session: {
      id: session.id,
      createdAt: session.createdAt,
      updatedAt: session.updatedAt,
      resume: {
        fileName: session.resume.fileName,
        fileType: session.resume.fileType,
        fileSizeBytes: session.resume.fileSizeBytes,
        extractedText: includeFullText
          ? session.resume.extractedText
          : `[Truncated - ${session.resume.extractionMeta.charCount} characters]`,
        extractionMeta: session.resume.extractionMeta,
      },
      job: session.job
        ? {
            rawText: includeFullText
              ? session.job.rawText
              : `[Truncated - ${session.job.rawText.length} characters]`,
            extractedKeywords: session.job.extractedKeywords,
            detectedKnockouts: session.job.detectedKnockouts,
          }
        : undefined,
      findings: session.findings,
      scores: session.scores,
      // Exclude BYOK metadata for privacy (don't export API key storage info)
      byok: session.byok
        ? {
            provider: session.byok.provider,
            model: session.byok.model,
            consentAt: session.byok.consentAt,
            // Intentionally omit keyStorageMode
          }
        : undefined,
    },
  };

  return prettyPrint
    ? JSON.stringify(exportData, null, 2)
    : JSON.stringify(exportData);
}

// =============================================================================
// Markdown Export
// =============================================================================

/**
 * Export options for Markdown format
 */
export interface MarkdownExportOptions {
  /** Maximum characters of resume text to include */
  maxTextPreview?: number;
  /** Include the job description analysis section */
  includeJobAnalysis?: boolean;
}

/**
 * Exports a session to Markdown format for human readability.
 *
 * @param session - The analysis session to export
 * @param options - Export options
 * @returns Markdown formatted string
 */
export function exportToMarkdown(
  session: ExportableSession,
  options: MarkdownExportOptions = {}
): string {
  const { maxTextPreview = 1500, includeJobAnalysis = true } = options;

  const lines: string[] = [];
  const grade = scoreToGrade(session.scores.parseHealth);

  // Header
  lines.push(`# Resume Analysis Report`);
  lines.push('');
  lines.push(`**Generated by:** ${APP_NAME}`);
  lines.push(`**Date:** ${formatDate(session.createdAt)}`);
  lines.push(`**File:** ${session.resume.fileName}`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Parse Health Summary
  lines.push('## Parse Health Score');
  lines.push('');
  lines.push(`### ${session.scores.parseHealth}/100 - ${grade}`);
  lines.push('');
  lines.push(getScoreEmoji(session.scores.parseHealth) + ' ' + getScoreDescription(session.scores.parseHealth));
  lines.push('');

  // Score Breakdown
  lines.push('#### Score Breakdown');
  lines.push('');
  lines.push(`| Category | Score |`);
  lines.push(`|----------|-------|`);
  lines.push(`| Layout & Structure | ${session.scores.layoutScore}/100 |`);
  lines.push(`| Contact Information | ${session.scores.contactScore}/100 |`);
  lines.push(`| Section Headers | ${session.scores.sectionScore}/100 |`);
  if (session.scores.keywordCoverage !== undefined) {
    lines.push(`| Keyword Coverage | ${session.scores.keywordCoverage}/100 |`);
  }
  lines.push('');

  // Knockout Risk (if JD provided)
  if (session.scores.knockoutRisk) {
    lines.push(`**Knockout Risk:** ${getKnockoutRiskLabel(session.scores.knockoutRisk)}`);
    lines.push('');
  }

  lines.push('---');
  lines.push('');

  // Findings Section
  lines.push('## Findings & Recommendations');
  lines.push('');

  if (session.findings.length === 0) {
    lines.push('No issues detected. Your resume appears to be well-formatted for ATS systems.');
    lines.push('');
  } else {
    // Group findings by severity (handle both session and analysis formats)
    const riskFindings = session.findings.filter((f) =>
      f.severity === 'risk' || f.severity === 'critical' || f.severity === 'high'
    );
    const warnFindings = session.findings.filter((f) =>
      f.severity === 'warn' || f.severity === 'medium'
    );
    const infoFindings = session.findings.filter((f) =>
      f.severity === 'info' || f.severity === 'low'
    );

    if (riskFindings.length > 0) {
      lines.push('### Critical Issues');
      lines.push('');
      riskFindings.forEach((f) => lines.push(...formatFinding(f as AnyFinding)));
    }

    if (warnFindings.length > 0) {
      lines.push('### Warnings');
      lines.push('');
      warnFindings.forEach((f) => lines.push(...formatFinding(f as AnyFinding)));
    }

    if (infoFindings.length > 0) {
      lines.push('### Suggestions');
      lines.push('');
      infoFindings.forEach((f) => lines.push(...formatFinding(f as AnyFinding)));
    }
  }

  lines.push('---');
  lines.push('');

  // Job Description Analysis (if provided)
  if (includeJobAnalysis && session.job) {
    lines.push('## Job Description Analysis');
    lines.push('');

    // Keywords
    if (session.job.extractedKeywords.critical.length > 0) {
      lines.push('### Critical Keywords');
      lines.push('');
      lines.push(session.job.extractedKeywords.critical.map((k) => `\`${k}\``).join(', '));
      lines.push('');
    }

    if (session.job.extractedKeywords.optional.length > 0) {
      lines.push('### Optional Keywords');
      lines.push('');
      lines.push(session.job.extractedKeywords.optional.map((k) => `\`${k}\``).join(', '));
      lines.push('');
    }

    // Knockouts
    if (session.job.detectedKnockouts.length > 0) {
      lines.push('### Potential Disqualifiers');
      lines.push('');
      session.job.detectedKnockouts.forEach((ko) => {
        const status = ko.userConfirmed === true
          ? 'âœ…'
          : ko.userConfirmed === false
          ? 'âŒ'
          : 'â“';
        lines.push(`- ${status} ${ko.label}`);
        if (ko.evidence) {
          lines.push(`  > "${ko.evidence}"`);
        }
      });
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  // Plain Text Preview
  lines.push('## Extracted Text Preview');
  lines.push('');
  lines.push('*This is how your resume appears to ATS systems after parsing:*');
  lines.push('');
  lines.push('```');
  const previewText = session.resume.extractedText.length > maxTextPreview
    ? session.resume.extractedText.substring(0, maxTextPreview) + '\n\n[... truncated ...]'
    : session.resume.extractedText;
  lines.push(previewText);
  lines.push('```');
  lines.push('');

  // Document Info
  lines.push('---');
  lines.push('');
  lines.push('## Document Information');
  lines.push('');
  lines.push(`- **File Name:** ${session.resume.fileName}`);
  lines.push(`- **File Type:** ${session.resume.fileType.toUpperCase()}`);
  lines.push(`- **File Size:** ${formatFileSize(session.resume.fileSizeBytes)}`);
  lines.push(`- **Characters Extracted:** ${session.resume.extractionMeta.charCount.toLocaleString()}`);
  if (session.resume.extractionMeta.pageCount) {
    lines.push(`- **Pages:** ${session.resume.extractionMeta.pageCount}`);
  }
  lines.push('');

  // Footer
  lines.push('---');
  lines.push('');
  lines.push(`*Report generated by [${APP_NAME}](https://jalanea.works) on ${formatDate(new Date().toISOString())}*`);
  lines.push('');

  return lines.join('\n');
}

// =============================================================================
// File Download
// =============================================================================

/**
 * Triggers a browser download for the given content.
 *
 * @param content - The file content as a string
 * @param filename - The filename for the download
 * @param mimeType - The MIME type of the content
 */
export function downloadFile(
  content: string,
  filename: string,
  mimeType: string
): void {
  // Create blob
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);

  // Create temporary link and trigger download
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.style.display = 'none';

  document.body.appendChild(link);
  link.click();

  // Cleanup
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Generates a timestamped filename for exports.
 *
 * @param baseName - The base name for the file
 * @param extension - The file extension (without dot)
 * @returns Formatted filename
 */
export function generateFilename(baseName: string, extension: string): string {
  const date = new Date();
  const timestamp = date.toISOString().split('T')[0]; // YYYY-MM-DD
  const safeName = baseName.replace(/[^a-zA-Z0-9-_]/g, '-').toLowerCase();
  return `${safeName}-analysis-${timestamp}.${extension}`;
}

// =============================================================================
// Convenience Export Functions
// =============================================================================

/**
 * Exports and downloads the session as JSON.
 *
 * @param session - The analysis session to export
 * @param options - Export options
 */
export function downloadAsJSON(
  session: ExportableSession,
  options?: JsonExportOptions
): void {
  const content = exportToJSON(session, options);
  const filename = generateFilename(
    session.resume.fileName.replace(/\.[^.]+$/, ''),
    'json'
  );
  downloadFile(content, filename, 'application/json');
}

/**
 * Exports and downloads the session as Markdown.
 *
 * @param session - The analysis session to export
 * @param options - Export options
 */
export function downloadAsMarkdown(
  session: ExportableSession,
  options?: MarkdownExportOptions
): void {
  const content = exportToMarkdown(session, options);
  const filename = generateFilename(
    session.resume.fileName.replace(/\.[^.]+$/, ''),
    'md'
  );
  downloadFile(content, filename, 'text/markdown');
}

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Formats an ISO date string to a human-readable format.
 */
function formatDate(isoString: string): string {
  const date = new Date(isoString);
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  });
}

/**
 * Formats file size in bytes to human-readable format.
 */
function formatFileSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} bytes`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
}

/**
 * Gets an emoji for the score level.
 */
function getScoreEmoji(score: number): string {
  if (score >= 90) return 'ðŸŽ‰';
  if (score >= 75) return 'ðŸ‘';
  if (score >= 50) return 'âš ï¸';
  return 'ðŸš¨';
}

/**
 * Gets a description for the score level.
 */
function getScoreDescription(score: number): string {
  if (score >= 90) {
    return 'Excellent! Your resume is highly parsable by ATS systems.';
  }
  if (score >= 75) {
    return 'Good! Your resume should parse well in most ATS systems.';
  }
  if (score >= 50) {
    return 'Fair. Some ATS systems may have trouble parsing parts of your resume.';
  }
  return 'Poor. Your resume may not parse correctly in many ATS systems. Review the findings below.';
}

/**
 * Gets a human-readable label for knockout risk.
 */
function getKnockoutRiskLabel(risk: 'low' | 'medium' | 'high'): string {
  switch (risk) {
    case 'low':
      return 'ðŸŸ¢ Low - You appear to meet the key requirements';
    case 'medium':
      return 'ðŸŸ¡ Medium - Some requirements need verification';
    case 'high':
      return 'ðŸ”´ High - You may not meet critical requirements';
  }
}

/**
 * Formats a finding for Markdown output.
 * Supports both session and analysis finding formats.
 */
function formatFinding(finding: AnyFinding): string[] {
  const lines: string[] = [];

  // Map severity to icon - handle both formats
  const severity = finding.severity;
  let icon = 'ðŸ”µ'; // default for info
  if (severity === 'risk' || severity === 'critical' || severity === 'high') {
    icon = 'ðŸ”´';
  } else if (severity === 'warn' || severity === 'medium') {
    icon = 'ðŸŸ¡';
  }

  lines.push(`#### ${icon} ${finding.title}`);
  lines.push('');

  // Handle both finding formats - session uses whyItMatters, analysis uses description/impact
  const whyItMatters = 'whyItMatters' in finding
    ? finding.whyItMatters
    : ('description' in finding ? finding.description : '');

  const fix = 'fix' in finding
    ? finding.fix
    : ('suggestion' in finding ? finding.suggestion : '');

  if (whyItMatters) {
    lines.push(`**Why it matters:** ${whyItMatters}`);
    lines.push('');
  }

  if (fix) {
    lines.push(`**How to fix:** ${fix}`);
    lines.push('');
  }

  // Handle evidence (session format)
  if ('evidence' in finding && finding.evidence) {
    lines.push(`> Evidence: "${finding.evidence}"`);
    lines.push('');
  }

  return lines;
}
